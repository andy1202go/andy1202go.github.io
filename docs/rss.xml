<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Andy's Blog</title><link>https://andy1202go.github.io</link><description>Tech Experience Learn Think</description><copyright>Andy's Blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/11980041</url><title>avatar</title><link>https://andy1202go.github.io</link></image><lastBuildDate>Thu, 27 Jun 2024 07:52:57 +0000</lastBuildDate><managingEditor>Andy's Blog</managingEditor><ttl>60</ttl><webMaster>Andy's Blog</webMaster><item><title>数据结构与算法之美(1) 开篇</title><link>https://andy1202go.github.io/post/shu-ju-jie-gou-yu-suan-fa-zhi-mei-%281%29%20-kai-pian.html</link><description>## 1 定位&#13;
&#13;
- 基础内容&#13;
- 知道有哪些，是什么，怎么用&#13;
- 分为入门、基础、高级、实战&#13;
&#13;
## 2 期望&#13;
&#13;
- 对数据结构和算法有初步认知&#13;
- 在平时设计和编写代码能用起来&#13;
&#13;
## 3 老生常谈，为什么要学习数据结构和算法&#13;
&#13;
因为要从唯一性原理出发，探查本质。</description><guid isPermaLink="true">https://andy1202go.github.io/post/shu-ju-jie-gou-yu-suan-fa-zhi-mei-%281%29%20-kai-pian.html</guid><pubDate>Thu, 27 Jun 2024 07:52:34 +0000</pubDate></item><item><title>EffectiveJava(6) 类和接口 Part1</title><link>https://andy1202go.github.io/post/EffectiveJava%286%29%20-lei-he-jie-kou-%20Part1.html</link><description>如何使用Java提供的基本元素来合理设计类和接口。</description><guid isPermaLink="true">https://andy1202go.github.io/post/EffectiveJava%286%29%20-lei-he-jie-kou-%20Part1.html</guid><pubDate>Thu, 27 Jun 2024 07:45:58 +0000</pubDate></item><item><title>EffectiveJava(5) 对于所有对象都通用的方法 Part2</title><link>https://andy1202go.github.io/post/EffectiveJava%285%29%20-dui-yu-suo-you-dui-xiang-du-tong-yong-de-fang-fa-%20Part2.html</link><description>## 12 始终重写toString方法&#13;
&#13;
### 为什么&#13;
&#13;
- Object提供的toString方法，不好用，是类名@十六进制的展示，看不懂啥意思&#13;
&#13;
  ```java&#13;
  //    * It is recommended that all subclasses override this method.    &#13;
  public String toString() {&#13;
          return getClass().getName() + '@' + Integer.toHexString(hashCode());&#13;
      }&#13;
  ```&#13;
&#13;
- 官方都说，强烈建议，所有类都重写这个方法&#13;
&#13;
- 没有约定，想equals和hashcode那样，但良好的toString方法，对后续的使用大有益处。</description><guid isPermaLink="true">https://andy1202go.github.io/post/EffectiveJava%285%29%20-dui-yu-suo-you-dui-xiang-du-tong-yong-de-fang-fa-%20Part2.html</guid><pubDate>Thu, 27 Jun 2024 07:43:30 +0000</pubDate></item><item><title>EffectiveJava(4) 对于所有对象都通用的方法 Part1</title><link>https://andy1202go.github.io/post/EffectiveJava%284%29%20-dui-yu-suo-you-dui-xiang-du-tong-yong-de-fang-fa-%20Part1.html</link><description>&gt; 尽管Object是一个具体的类，但设计它主要是为了拓展。</description><guid isPermaLink="true">https://andy1202go.github.io/post/EffectiveJava%284%29%20-dui-yu-suo-you-dui-xiang-du-tong-yong-de-fang-fa-%20Part1.html</guid><pubDate>Thu, 27 Jun 2024 07:41:24 +0000</pubDate></item><item><title>EffectiveJava(3) 创建和销毁对象 Part3</title><link>https://andy1202go.github.io/post/EffectiveJava%283%29%20-chuang-jian-he-xiao-hui-dui-xiang-%20Part3.html</link><description>## 7 消除过期的对象引用&#13;
&#13;
简单来说，就是对象过期了，但引用还在，就会占用内存不释放。</description><guid isPermaLink="true">https://andy1202go.github.io/post/EffectiveJava%283%29%20-chuang-jian-he-xiao-hui-dui-xiang-%20Part3.html</guid><pubDate>Thu, 27 Jun 2024 07:39:00 +0000</pubDate></item><item><title>EffectiveJava(2) 创建和销毁对象 Part2</title><link>https://andy1202go.github.io/post/EffectiveJava%282%29%20-chuang-jian-he-xiao-hui-dui-xiang-%20Part2.html</link><description>## 4 使用私有构造方法强化不可实例化&#13;
&#13;
有些类，不可实例化：&#13;
&#13;
- 只包含静态方法和静态字段&#13;
- 比如java.lang.Math java.util.Arrays&#13;
- java.util.Collections还把一些工厂方法放进去了，比如UnmodifiableCollection这种只读类型的类，可以通过Collections.unmodifiableCollection()方法获得实例&#13;
&#13;
这种不可以实例的类，通常是工具类&#13;
&#13;
&gt; 这样的工具类（utility classes）不是设计用来被实例化的，因为实例化对它没有任何意义。</description><guid isPermaLink="true">https://andy1202go.github.io/post/EffectiveJava%282%29%20-chuang-jian-he-xiao-hui-dui-xiang-%20Part2.html</guid><pubDate>Thu, 27 Jun 2024 07:38:20 +0000</pubDate></item><item><title>EffectiveJava(1) 创建和销毁对象 Part1</title><link>https://andy1202go.github.io/post/EffectiveJava%281%29%20-chuang-jian-he-xiao-hui-dui-xiang-%20Part1.html</link><description>## 1 考虑使用静态工厂方法替代构造方法&#13;
&#13;
静态工厂方法，指的是类中的静态方法，用于创建类的工厂方法；&#13;
&#13;
和设计模式中的工厂方法主要区别在于&#13;
&#13;
- 静态工厂方法创建的是同一个实例，比如Boolean.of()，返回的是TRUE和FALSE两个实例中的一个，没有更多的&#13;
- 工厂方法，永远是new一个&#13;
&#13;
先看下Boolean的静态工厂方法实例吧&#13;
&#13;
```java&#13;
public final class Boolean implements java.io.Serializable,&#13;
                                      Comparable&lt;Boolean&gt;&#13;
{&#13;
    /**&#13;
     * The {@code Boolean} object corresponding to the primitive&#13;
     * value {@code true}.&#13;
     */&#13;
    public static final Boolean TRUE = new Boolean(true);&#13;
&#13;
    /**&#13;
     * The {@code Boolean} object corresponding to the primitive&#13;
     * value {@code false}.&#13;
     */&#13;
    public static final Boolean FALSE = new Boolean(false);&#13;
                                   &#13;
    public static Boolean valueOf(String s) {&#13;
        return parseBoolean(s) ? TRUE : FALSE;&#13;
    }                                      &#13;
  }&#13;
```&#13;
&#13;
工厂方法的简单工厂，抽象工厂就不写了；但是静态工厂方法和静态单例模式还是挺像的，比如&#13;
&#13;
```java&#13;
public class Singleton{&#13;
    //lazy&#13;
    private static Singleton instance = null;&#13;
    &#13;
    //private防止直接构造&#13;
    private Singleton(){}&#13;
    &#13;
    public static Singleton getInstance(){&#13;
        if(instance == null){&#13;
            synchronized (Singleton.class) {&#13;
                if (instance == null) {&#13;
                    instance = new Singleton();&#13;
                }&#13;
            }&#13;
        }&#13;
        return instance;&#13;
    }&#13;
}&#13;
```&#13;
&#13;
静态工厂方法的优点&#13;
&#13;
- 可读性更好：有名字，可以直接表示含义，比如Collections.emptyList()&#13;
- 与构造方法不同，它们不需要每次调用时都创建一个新对象&#13;
- 可以返回该类的任意子类：比如Collections.unmodifiableList();&#13;
- 静态工厂的第四个优点是返回对象的类可以根据输入参数的不同而不同&#13;
- 静态工厂的第五个优点是，在编写包含该方法的类时，返回的对象的类不需要存在&#13;
&#13;
缺点&#13;
&#13;
- 名字用于表示含义了，没有标识是实例化的方法：所以用getInstance，newInstance什么的命名，保留至少一个&#13;
- 如果类不含public或protect的构造方法，将不能被继承：这也是单例模式的问题，分需要使用的情况来决定吧&#13;
&#13;
综上，给出两种较好的实现：一种是单例模式，线程安全的静态方法；一种如下&#13;
&#13;
```java&#13;
public class RandomIntGenerator {&#13;
    /**&#13;
     * 最小值&#13;
     */&#13;
    private int min = Integer.MIN_VALUE;&#13;
    /**&#13;
     * 最大值&#13;
     */&#13;
    private int max = Integer.MAX_VALUE;&#13;
&#13;
    /**&#13;
     * 大于min 小于max&#13;
     * @param min&#13;
     * @param max&#13;
     */&#13;
    public RandomIntGenerator(int min, int max)&#13;
    {&#13;
        this.min = min;&#13;
        this.max = max;&#13;
    }&#13;
    &#13;
    /**&#13;
     * 大于min 小于max&#13;
     * @param min&#13;
     * @param max&#13;
     */&#13;
    public static RandomIntGenerator between(int min, int max)&#13;
    {&#13;
        return new RandomIntGenerator(min, max);&#13;
    }&#13;
    /**&#13;
     * 大于min 小于Integer.MAX_VALUE&#13;
     */&#13;
    public static RandomIntGenerator biggerThan(int min)&#13;
    {&#13;
        return new RandomIntGenerator(min, Integer.MAX_VALUE);&#13;
    }&#13;
&#13;
    /**&#13;
     * 大于Integer.MIN_VALUE 小于max&#13;
     */&#13;
    public static RandomIntGenerator smallerThan(int max)&#13;
    {&#13;
        return new RandomIntGenerator(Integer.MIN_VALUE, max);&#13;
    }&#13;
&#13;
    public static RandomIntGenerator getInstance(){&#13;
        return new RandomIntGenerator(Integer.MIN_VALUE, Integer.MAX_VALUE);&#13;
    }&#13;
}&#13;
```&#13;
&#13;
### 使用体验&#13;
&#13;
- 感觉更多的是工具类可以这么去定义，毕竟都是单例&#13;
- spring本身都是单例了，其实也不需要单独这个了&#13;
&#13;
## 2 当构造方法参数过多时使用builder模式&#13;
&#13;
构造方法比较多的时候，比较几种构造设计&#13;
&#13;
- 伸缩构造方法：就是构造方法中强行塞参数&#13;
- JavaBeans：就是属性都是private，通过setter来构造&#13;
- Builder模式&#13;
&#13;
使用Builder模式的优势&#13;
&#13;
- 可读性好&#13;
- 更安全（相比于JavaBeans，因为JavaBeans的构造方法被割裂为了多次调用，可能导致实例不一致）&#13;
- 可以有多个可变参数，其实就是递归使用builder的某个方法，微小优势，不常用&#13;
&#13;
缺点：&#13;
&#13;
- 代码冗长，因为要单独写builder&#13;
&#13;
综合考虑&#13;
&#13;
- 参数大于等于4个的时候，最好使用builder模式&#13;
- 注意：需要估计类的参数数量，在一开始的时候，而不是从一种构造方法切换到builder模式，代价较大&#13;
&#13;
最佳实践1&#13;
&#13;
- 使用Lombok的@Builder&#13;
&#13;
  ```java&#13;
  import lombok.Builder;&#13;
  &#13;
  @Builder&#13;
  public class SingletonBuilder {&#13;
      private String param1;&#13;
      private String param2;&#13;
      private String param3;&#13;
      private String param4;&#13;
  }&#13;
  ```&#13;
&#13;
- 手写Builder&#13;
&#13;
  ```java&#13;
  // Builder Pattern&#13;
  public class NutritionFacts {&#13;
      private final int servingSize;&#13;
      private final int servings;&#13;
      private final int calories;&#13;
      private final int fat;&#13;
      private final int sodium;&#13;
      private final int carbohydrate;&#13;
      public static class Builder {&#13;
          // Required parameters&#13;
          private final int servingSize;&#13;
          private final int servings;&#13;
          // Optional parameters - initialized to default values&#13;
          private int calories      = 0;&#13;
          private int fat           = 0;&#13;
          private int sodium        = 0;&#13;
          private int carbohydrate  = 0;&#13;
          public Builder(int servingSize, int servings) {&#13;
              this.servingSize = servingSize;&#13;
              this.servings    = servings;&#13;
          }&#13;
          public Builder calories(int val) { &#13;
              calories = val;      &#13;
          }&#13;
          public Builder fat(int val) { &#13;
             fat = val;           &#13;
             return this;&#13;
          }&#13;
          public Builder sodium(int val) { &#13;
             sodium = val;        &#13;
             return this; &#13;
          }&#13;
          public Builder carbohydrate(int val) { &#13;
             carbohydrate = val;  &#13;
             return this; &#13;
          }&#13;
          public NutritionFacts build() {&#13;
              return new NutritionFacts(this);&#13;
          }&#13;
      }&#13;
      private NutritionFacts(Builder builder) {&#13;
          servingSize  = builder.servingSize;&#13;
          servings     = builder.servings;&#13;
          calories     = builder.calories;&#13;
          fat          = builder.fat;&#13;
          sodium       = builder.sodium;&#13;
          carbohydrate = builder.carbohydrate;&#13;
      }&#13;
  }&#13;
  ```&#13;
&#13;
- 抽象基类使用Builder实现可变参数构造&#13;
&#13;
  ```java&#13;
  public abstract class Pizza {&#13;
      public enum Topping {HAM,MUSHROOM,ONION,PEPPER,SAUSAGE}&#13;
      final Set&lt;Topping&gt; toppings;&#13;
  &#13;
      abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt; {&#13;
          EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class);&#13;
          public T addTopping(Topping topping){&#13;
              toppings.add(Objects.requireNonNull(topping));&#13;
              return self();//模拟的self类型&#13;
          }&#13;
          abstract Pizza build();&#13;
  &#13;
          // Subclasses must override this method to return 'this'&#13;
          protected abstract T self();&#13;
      }&#13;
  &#13;
      Pizza(Builder&lt;?&gt; builder) {&#13;
          toppings = builder.toppings.clone();&#13;
      }&#13;
  }&#13;
  ```&#13;
&#13;
### 使用体验&#13;
&#13;
## 3 使用私有构造方法或枚举实现单例模式&#13;
&#13;
讨论了3种实现单例模式的优劣，分别是&#13;
&#13;
- 私有构造方法+公开的实例；&#13;
&#13;
  ```java&#13;
  public class Singleton{&#13;
      private Singleton(){}&#13;
      public static final Singleton INSTANCE = new Singleton();&#13;
  }&#13;
  ```&#13;
&#13;
- 私有构造方法+私有的实例+公开的静态方法获取实例&#13;
&#13;
  ```java&#13;
  public class Singleton{&#13;
      private Singleton(){}&#13;
      private static final Singleton INSTANCE = new Singleton();&#13;
      public static Singleton getInstance(){&#13;
          return INSTANCE;&#13;
      }&#13;
  }&#13;
  ```&#13;
&#13;
- 枚举&#13;
&#13;
  ```java&#13;
  public enum Singleton {&#13;
      INSTANCE;&#13;
  }&#13;
  ```&#13;
&#13;
书中最倾向使用枚举来实现单例，原因如下：&#13;
&#13;
- 最简洁&#13;
&#13;
- 无偿地提供了序列化机制（还不怎么理解..https://www.jianshu.com/p/d3d797c3cd45）&#13;
&#13;
  &gt; 绝对防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候&#13;
&#13;
其次是静态工厂的模式，优点在于&#13;
&#13;
- 通过API表示这是单例模式&#13;
- 灵活&#13;
  - 需要改变为每个调用该方法的线程返回一个唯一的实例，直接在静态工厂方法中 new instance()，但此时需要去掉单例对象中final修饰的关键字&#13;
  - 如果应用程序需要他，我们可以将它改为一个泛型单例工厂（条目30）&#13;
&#13;
缺点在于，小心序列化问题（第11章有讨论）&#13;
&#13;
&gt; 为了防止单例类变成可序列化的，仅仅将添加 *implements Serializable* 到声明中是不够的。</description><guid isPermaLink="true">https://andy1202go.github.io/post/EffectiveJava%281%29%20-chuang-jian-he-xiao-hui-dui-xiang-%20Part1.html</guid><pubDate>Thu, 27 Jun 2024 07:37:44 +0000</pubDate></item><item><title>JavaScript(8) 浏览器</title><link>https://andy1202go.github.io/post/JavaScript%288%29%20-liu-lan-qi.html</link><description>JavaScript的出现就是为了能在浏览器中运行。</description><guid isPermaLink="true">https://andy1202go.github.io/post/JavaScript%288%29%20-liu-lan-qi.html</guid><pubDate>Thu, 27 Jun 2024 07:35:11 +0000</pubDate></item><item><title>JavaScript(7) 面向对象编程</title><link>https://andy1202go.github.io/post/JavaScript%287%29%20-mian-xiang-dui-xiang-bian-cheng.html</link><description>JavaScript虽然所有数据都是对象，但不是就能原生实现面向对象编程的。</description><guid isPermaLink="true">https://andy1202go.github.io/post/JavaScript%287%29%20-mian-xiang-dui-xiang-bian-cheng.html</guid><pubDate>Thu, 27 Jun 2024 07:33:31 +0000</pubDate></item><item><title>JavaScript(6) 标准对象</title><link>https://andy1202go.github.io/post/JavaScript%286%29%20-biao-zhun-dui-xiang.html</link><description>在JavaScript的世界里，一切都是对象。</description><guid isPermaLink="true">https://andy1202go.github.io/post/JavaScript%286%29%20-biao-zhun-dui-xiang.html</guid><pubDate>Thu, 27 Jun 2024 07:32:09 +0000</pubDate></item><item><title>JavaScript(5) 函数 Part3</title><link>https://andy1202go.github.io/post/JavaScript%285%29%20-han-shu-%20Part3.html</link><description>## 5 闭包&#13;
&#13;
高阶函数除了可以接受函数作为参数外，还可以把函数作为结果返回。</description><guid isPermaLink="true">https://andy1202go.github.io/post/JavaScript%285%29%20-han-shu-%20Part3.html</guid><pubDate>Thu, 27 Jun 2024 07:29:28 +0000</pubDate></item><item><title>JavaScript(4) 函数 Part2</title><link>https://andy1202go.github.io/post/JavaScript%284%29%20-han-shu-%20Part2.html</link><description>## 3 方法&#13;
&#13;
在一个对象中绑定函数，是这个对象的方法，举例&#13;
&#13;
```javascript&#13;
var xiaoming = {&#13;
    name: '小明',&#13;
    birth: 1990,&#13;
    age: function () {&#13;
        var y = new Date().getFullYear();&#13;
        return y - this.birth;&#13;
    }&#13;
};&#13;
&#13;
xiaoming.age; // function xiaoming.age()&#13;
xiaoming.age(); // 今年调用是25,明年调用就变成26了&#13;
```&#13;
&#13;
#### this和that&#13;
&#13;
- 方法中的this指当前对象&#13;
&#13;
- 当方法中嵌套函数的时候，再使用this会有意想不到的结果...此时的this可能指向全局对象window，或者undefined&#13;
&#13;
- 修复方法是使用一个that在函数一开始就捕获this，后续都使用that，利用嵌套函数变量作用域&#13;
&#13;
  ```javascript&#13;
  'use strict';&#13;
  &#13;
  var xiaoming = {&#13;
      name: '小明',&#13;
      birth: 1990,&#13;
      age: function () {&#13;
          var that = this; // 在方法内部一开始就捕获this&#13;
          function getAgeFromBirth() {&#13;
              var y = new Date().getFullYear();&#13;
              return y - that.birth; // 用that而不是this&#13;
          }&#13;
          return getAgeFromBirth();&#13;
      }&#13;
  };&#13;
  &#13;
  xiaoming.age(); // 25&#13;
  ```&#13;
&#13;
#### apply&#13;
&#13;
函数本身都具有apply方法。</description><guid isPermaLink="true">https://andy1202go.github.io/post/JavaScript%284%29%20-han-shu-%20Part2.html</guid><pubDate>Thu, 27 Jun 2024 07:28:38 +0000</pubDate></item><item><title>JavaScript(3) 函数 Part1</title><link>https://andy1202go.github.io/post/JavaScript%283%29%20-han-shu-%20Part1.html</link><description>## 1 函数定义和调用&#13;
&#13;
常规定义：&#13;
&#13;
```javascript&#13;
function abs(x){&#13;
    ...&#13;
}&#13;
```&#13;
&#13;
- function指出这是一个函数定义&#13;
- abs是函数名&#13;
- (x)内是函数的参数，多个以逗号分隔&#13;
- {}是函数体&#13;
&#13;
需要注意：&#13;
&#13;
- 一旦执行到return就结束函数&#13;
- 如果没有return，会返回undefined&#13;
&#13;
由于JavaScript的函数也是一个对象，所以有另一种函数定义方法&#13;
&#13;
```javascript&#13;
var abs = function(x){&#13;
    ...&#13;
};&#13;
```&#13;
&#13;
需要注意：&#13;
&#13;
- 这种方式要有分号结尾&#13;
- 使用上完全相同&#13;
&#13;
另外，JavaScript对函数入参比较随意，需要格外注意&#13;
&#13;
```javascript&#13;
abs(10, 'blablabla'); // 多个参数，只用了第一个；返回10&#13;
abs(-9, 'haha', 'hehe', null); // 返回9&#13;
abs(); // 返回NaN&#13;
&#13;
//改良&#13;
function abs(x) {&#13;
    if (typeof x !== 'number') {&#13;
        throw 'Not a number';&#13;
    }&#13;
    if (x &gt;= 0) {&#13;
        return x;&#13;
    } else {&#13;
        return -x;&#13;
    }&#13;
}&#13;
```&#13;
&#13;
### arguments&#13;
&#13;
&gt; JavaScript还有一个免费赠送的关键字`arguments`，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。</description><guid isPermaLink="true">https://andy1202go.github.io/post/JavaScript%283%29%20-han-shu-%20Part1.html</guid><pubDate>Thu, 27 Jun 2024 07:27:36 +0000</pubDate></item><item><title>JavaScript(2) 入门 Part2</title><link>https://andy1202go.github.io/post/JavaScript%282%29%20-ru-men-%20Part2.html</link><description>## 6 对象&#13;
&#13;
- 访问属性是通过`.`操作符完成的，但这要求属性名必须是一个有效的变量名。</description><guid isPermaLink="true">https://andy1202go.github.io/post/JavaScript%282%29%20-ru-men-%20Part2.html</guid><pubDate>Thu, 27 Jun 2024 07:24:46 +0000</pubDate></item><item><title>JavaScript(1) 入门 Part1</title><link>https://andy1202go.github.io/post/JavaScript%281%29%20-ru-men-%20Part1.html</link><description>&gt; 简单地说，JavaScript是一种运行在浏览器中的解释型的编程语言。</description><guid isPermaLink="true">https://andy1202go.github.io/post/JavaScript%281%29%20-ru-men-%20Part1.html</guid><pubDate>Thu, 27 Jun 2024 07:24:03 +0000</pubDate></item><item><title>业务系统要求浅要总结</title><link>https://andy1202go.github.io/post/ye-wu-xi-tong-yao-qiu-qian-yao-zong-jie.html</link><description># 业务系统要求&#13;
&#13;
一句话目标：建立好负责的项目&#13;
&#13;
项目要达到&#13;
&#13;
|              | 性能要求  开发要求    效率要求  质量要求 |&#13;
| ------------ | ---------------------------------------- |&#13;
| **应用视角** | 高并发   开发速度快  并行开发  高可用    |&#13;
| **底层视角** | 云原生    分布式      微服务    k8s      |&#13;
| **抽象视角** | 流量治理  服务治理    资源治理  数据治理 |&#13;
&#13;
## 应用视角&#13;
&#13;
### 高并发系统&#13;
&#13;
#### 什么是高并发？&#13;
&#13;
&gt; 高并发是指特定的系统或应用程序可以同时处理大量的并发处理请求，要求其能够同时应付高流量的访问。</description><guid isPermaLink="true">https://andy1202go.github.io/post/ye-wu-xi-tong-yao-qiu-qian-yao-zong-jie.html</guid><pubDate>Thu, 27 Jun 2024 07:20:02 +0000</pubDate></item><item><title>Python菜鸟入门</title><link>https://andy1202go.github.io/post/Python-cai-niao-ru-men.html</link><description>## [[Python3 教程 | 菜鸟教程](https://www.runoob.com/python/python-tutorial.html)](https://www.runoob.com/python/python-tutorial.html)&#13;
&#13;
**[[Python Tutor: Visualize code](https://pythontutor.com/visualize.html#mode=edit)](https://pythontutor.com/visualize.html#mode=edit)**&#13;
&#13;
### Python 发展历史&#13;
&#13;
Python 是由 Guido van Rossum 在八十年代末和九十年代初，在荷兰国家数学和计算机科学研究所设计出来的。</description><guid isPermaLink="true">https://andy1202go.github.io/post/Python-cai-niao-ru-men.html</guid><pubDate>Thu, 27 Jun 2024 07:16:53 +0000</pubDate></item><item><title>Linux 入门 Part3</title><link>https://andy1202go.github.io/post/Linux%20-ru-men-%20Part3.html</link><description>## 2 Shell语言的知识内容&#13;
&#13;
略&#13;
&#13;
## 3 Linux相关的参考手册&#13;
&#13;
1. [[Linux 命令大全](https://www.w3cschool.cn/linux/linux-command-manual.html)](https://www.w3cschool.cn/linux/linux-command-manual.html)&#13;
2. [[Nginx 安装配置](https://www.w3cschool.cn/linux/u5xv1rha.html)](https://www.w3cschool.cn/linux/u5xv1rha.html)&#13;
3. [[MySQL 安装配置](https://www.w3cschool.cn/linux/z29j1rhv.html)](https://www.w3cschool.cn/linux/z29j1rhv.html)&#13;
4. [[linux删除文件夹命令使用方法](https://www.w3cschool.cn/linux/linux-9yfc2oyy.html)](https://www.w3cschool.cn/linux/linux-9yfc2oyy.html)&#13;
5. [[Linux关机命令和重启命令说明](https://www.w3cschool.cn/linux/linux-are12oz3.html)](https://www.w3cschool.cn/linux/linux-are12oz3.html)&#13;
&#13;
## 参考资料&#13;
&#13;
[[Linux 教程](https://www.w3cschool.cn/linux/)](https://www.w3cschool.cn/linux/)&#13;
&#13;
[[谈谈如何学习Linux操作系统](http://ixdba.blog.51cto.com/2895551/569329/)](http://ixdba.blog.51cto.com/2895551/569329/)&#13;
&#13;
[[Linux官网](http://www.linux.org/)](http://www.linux.org/) （此网站经常显示服务器错误）&#13;
&#13;
[[Linux下载](https://www.linux.org/pages/download/)](https://www.linux.org/pages/download/)&#13;
&#13;
[[Linux API文档](http://download.csdn.net/detail/a7320760/3617981)](http://download.csdn.net/detail/a7320760/3617981)&#13;
&#13;
[[Linux教程](https://www.w3cschool.cn/linux)](https://www.w3cschool.cn/linux)&#13;
&#13;
[[Linux视频课程](https://www.w3cschool.cn/minicourse/play/linux_my)](https://www.w3cschool.cn/minicourse/play/linux_my)&#13;
&#13;
[[Linux问答](https://www.w3cschool.cn/topic/linux)](。</description><guid isPermaLink="true">https://andy1202go.github.io/post/Linux%20-ru-men-%20Part3.html</guid><pubDate>Thu, 27 Jun 2024 07:14:23 +0000</pubDate></item><item><title>Linux 入门 Part2</title><link>https://andy1202go.github.io/post/Linux%20-ru-men-%20Part2.html</link><description>### 1.6 文件与目录管理&#13;
&#13;
- 绝对路径，就是从/根目录开始的&#13;
- 相对路径，相对于当前所在的目录&#13;
&#13;
#### 处理目录的常用命令&#13;
&#13;
接下来我们就来看几个常见的处理目录的命令吧：&#13;
&#13;
- ls: 列出目录&#13;
- cd：切换目录&#13;
- pwd：显示目前的目录&#13;
- mkdir：创建一个新的目录&#13;
- rmdir：删除一个空的目录&#13;
- cp: 复制文件或目录&#13;
- rm: 移除文件或目录&#13;
- mv: 移动文件与目录、文件重命名&#13;
&#13;
你可以使用 *man [命令]* 来查看各个命令的使用文档，如 ：man cp。</description><guid isPermaLink="true">https://andy1202go.github.io/post/Linux%20-ru-men-%20Part2.html</guid><pubDate>Thu, 27 Jun 2024 07:13:48 +0000</pubDate></item><item><title>Linux入门 Part1</title><link>https://andy1202go.github.io/post/Linux-ru-men-%20Part1.html</link><description>&#13;
&gt; 初级阶段：&#13;
&gt; 1． 命令是必须要学的，linux常用的命令大概在80个左右，这些常用命令一定要熟练掌握。</description><guid isPermaLink="true">https://andy1202go.github.io/post/Linux-ru-men-%20Part1.html</guid><pubDate>Thu, 27 Jun 2024 07:12:33 +0000</pubDate></item><item><title>Test2</title><link>https://andy1202go.github.io/post/Test2.html</link><description>1231。</description><guid isPermaLink="true">https://andy1202go.github.io/post/Test2.html</guid><pubDate>Thu, 27 Jun 2024 07:11:51 +0000</pubDate></item><item><title>The Key To Accelerating Your Coding Skills-文章读后小结</title><link>https://andy1202go.github.io/post/The%20Key%20To%20Accelerating%20Your%20Coding%20Skills--wen-zhang-du-hou-xiao-jie.html</link><description>### 文章链接：http://blog.thefirehoseproject.com/posts/learn-to-code-and-be-self-reliant/&#13;
&#13;
&gt; 在系统地学习编程技能之前，我希望你能先看一下 ' The Key To Accelerating Your Coding Skills'， 这篇文章会告诉你如何有效地快速提高自己的编程能力。</description><guid isPermaLink="true">https://andy1202go.github.io/post/The%20Key%20To%20Accelerating%20Your%20Coding%20Skills--wen-zhang-du-hou-xiao-jie.html</guid><pubDate>Thu, 27 Jun 2024 03:02:19 +0000</pubDate></item></channel></rss>